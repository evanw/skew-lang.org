<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <link rel="stylesheet" href="style.css">
    <title>The Skew Programming Language</title>
    <meta name="viewport" content="width=450">
  </head>
  <body>
    <header>
      <div class="inner">
        <h1><b>Skew</b> is a web-first, cross-platform programming language with an optimizing compiler.</h1>
      </div>
    </header>

    <section class="editor">
      <div class="inner">
        <div class="input">
          <h2>
            <a href="javascript:void 0" class="dropdown">
              <span class="compiler-example">Skew</span>
              <ol class="menu">
                <li class="menu-item disabled">Load example:</li>
                <li class="menu-item" id="example-calculator">Calculator</li>
                <li class="menu-item" id="example-fizz-buzz">Fizz buzz</li>
                <li class="menu-item" id="example-raytracer">Raytracer</li>
                <li class="menu-item" id="example-sparks">Sparks</li>
                <li class="menu-item" id="example-type-wrapping">Type Wrapping</li>
              </ol>
              <span class="menu-arrow">&#9662;</span>
            </a>
            <a href="javascript:void 0" class="edit button">Edit</a>
          </h2>
          <div class="editor-wrapper">
            <pre id="editor"><span class="ace_comment"># Imported declarations are just for type checking</span>
@import
<span class="ace_keyword">namespace</span> document {
  <span class="ace_keyword">def</span> write(text string)
}

<span class="ace_comment"># The compiler inlines this function in release mode</span>
<span class="ace_keyword">def</span> mod(i int, n int, text string) string {
  <span class="ace_keyword">return</span> i % n == 0 ? text : <span class="ace_string">""</span>
}

<span class="ace_comment"># Execution starts at the entry point</span>
@entry
<span class="ace_keyword">def</span> fizzBuzz {
  <span class="ace_keyword">for</span> i <span class="ace_keyword">in</span> 1..101 {
    <span class="ace_keyword">var</span> text = mod(i, 3, <span class="ace_string">"Fizz"</span>) + mod(i, 5, <span class="ace_string">"Buzz"</span>)
    document.write((text == <span class="ace_string">""</span> ? i.toString : text) + <span class="ace_string">"\n"</span>)
  }
}</pre>
          </div>
        </div>
        <div class="output">
          <h2>
            <a href="javascript:void 0" class="dropdown">
              <span class="compiler-target">JS (Release)</span>
              <ol class="menu">
                <li class="menu-item disabled">Change target:</li>
                <li class="menu-item" id="target-javascript-debug">JS (Debug)</li>
                <li class="menu-item" id="target-javascript-release">JS (Release)</li>
                <li class="menu-item" id="target-csharp">C#</li>
              </ol>
              <span class="menu-arrow">&#9662;</span>
            </a>
            <a href="javascript:void 0" class="run button">Run</a>
          </h2>
          <pre>(<span class="ace_keyword">function</span>(){<span class="ace_keyword">function</span> c(){<span class="ace_keyword">for</span>(<span class="ace_keyword">var</span> a=1;a&lt;101;++a){<span class="ace_keyword">var</span> b=(a%3?<span class="ace_string">''</span>:<span class="ace_string">'Fizz'</span>)+(a%5?<span class="ace_string">''</span>:<span class="ace_string">'Buzz'</span>);document.write((b==<span class="ace_string">''</span>?a.toString():b)+<span class="ace_string">'\n'</span>)}}c()})();</pre>
        </div>
        <div class="clearfix"></div>
      </div>
    </section>

    <section>
      <div class="inner">
        <p class="warning">
          Warning: This is a hobby project and is still evolving rapidly.
          It can be used for real things (the compiler is written in itself) but the language and standard library are not completely stable yet.
        </p>

        <h3 id="what">What is it?</h3>

        <p>
          Skew is a programming language for building cross-platform software.
          It compiles to straightforward, readable source code in other languages and is designed to be easy to integrate into a mixed-language code base.
        </p>

        <p>
          The compiler currently contains a production-quality JavaScript target, a working C# target, and a partially-complete target for C++11.
          It can easily be extended to support languages like Java, Swift, C++/CX, Python, PHP, and so on.
        </p>

        <p>
          Notable features:
        </p>

        <ul>
          <li class="expandable">
            <button>Open declarations</button>
            <div class="reveal">
              <p>
                Unlike most object-oriented languages, all block declarations can be split up into multiple pieces.
                This makes it much easier to organize complex code (test code can be separate from the implementation, for example) and often also helps when used with conditional compilation.
              </p>
              <pre class="skew">enum EventType {
}

class Event {
  def type EventType
}

########################################
# Keyboard event

enum EventType {
  KEYBOARD
}

class Event {
  def asKeyboardEvent KeyboardEvent {
    assert(type == .KEYBOARD)
    return self as KeyboardEvent
  }
}

class KeyboardEvent : Event {
  over type EventType { return .KEYBOARD }
}

########################################
# Mouse event

enum EventType {
  MOUSE
}

class Event {
  def asMouseEvent MouseEvent {
    assert(type == .MOUSE)
    return self as MouseEvent
  }
}

class MouseEvent : Event {
  over type EventType { return .MOUSE }
}</pre>
              <p>
                Open declarations also make it possible to safely add to imported code and other libraries at compile time, sort of like C# extension methods.
              </p>
              <pre class="skew">class double {
  def radToDeg double {
    return self * 180 / Math.PI
  }

  def degToRad double {
    return self * Math.PI / 180
  }
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Operator overloading</button>
            <div class="reveal">
              <p>
                The compiler checks for operators on the first operand.
                Operator overloading can make code more readable in many cases, but can also dramatically reduce readability when used incorrectly.
                Use with good judgement.
              </p>
              <pre class="skew">enum Axis {
  X
  Y
}

class Vector {
  var x double
  var y double

  def -(p Vector) Vector {
    return new(x - p.x, y - p.y)
  }

  def [](a Axis) double {
    return a == .X ? x : y
  }

  def []=(a Axis, v double) {
    if a == .X { x = v }
    else { y = v }
  }
}

@export
class Player {
  var position Vector

  def deltaTo(other Player) Vector {
    return other.position - position
  }

  def moveAlongAxis(axis Axis, delta double) {
    position[axis] = position[axis] + delta
  }
}</pre>
              <p>
                The code above becomes this JavaScript code in debug mode:
              </p>
              <pre class="js">(function() {
  var Axis = {
    X: 0
  };

  function Vector(x, y) {
    this.x = x;
    this.y = y;
  }

  Vector.prototype.subtract = function(p) {
    return new Vector(this.x - p.x, this.y - p.y);
  };

  Vector.prototype.get = function(a) {
    return a == Axis.X ? this.x : this.y;
  };

  Vector.prototype.set = function(a, v) {
    if (a == Axis.X) {
      this.x = v;
    }

    else {
      this.y = v;
    }
  };

  Player = function(position) {
    this.position = position;
  };

  Player.prototype.deltaTo = function(other) {
    return other.position.subtract(this.position);
  };

  Player.prototype.moveAlongAxis = function(axis, delta) {
    this.position.set(axis, this.position.get(axis) + delta);
  };
})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Wrapped types</button>
            <div class="reveal">
              <p>
                Wrapped types are defined using the "type" keyword.
                They must be explicitly casted, which can be used to improve type safety.
              </p>
              <pre class="skew">type CSV = string

@export
def escapeForCSV(text string) CSV {
  if "\"" in text || "," in text || "\n" in text {
    return ("\"" + text.replaceAll("\"", "\"\"") + "\"") as CSV
  }
  return text as CSV
}</pre>
              <p>
                Wrapped types can also be used to add encapsulation without the overhead of additional allocation.
                Instance functions added to wrapped types are automatically rewritten as global functions during compilation that take the instance as an extra first argument.
              </p>
              <pre class="skew">type Color : int {
  def r int { return (self as int) &amp; 255 }
  def g int { return ((self as int) >> 8) &amp; 255 }
  def b int { return ((self as int) >> 16) &amp; 255 }
  def a int { return (self as int) >>> 24 }

  def opaque Color {
    return new(r, g, b, 255)
  }
}

namespace Color {
  def new(r int, g int, b int, a int) Color {
    return (r | g &lt;&lt; 8 | b &lt;&lt; 16 | a &lt;&lt; 24) as Color
  }
}

@export
def isOrange(color Color) bool {
  return color.opaque == Color.new(255, 127, 0, 255)
}</pre>
              <p>
                The code above becomes this JavaScript code in release mode:
              </p>
              <pre class="js">(function(){isOrange=function(a){return b(a)==-16744449};function b(a){return a|-16777216}})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Conditional compilation</button>
            <div class="reveal">
              <p>
                Top-level if statements allow for conditional code compilation.
                Like all declarations, top-level if statements are also order-independent and are evaluated from the outside in.
                Conditions must be compile-time constants but are fully type-checked, unlike the C preprocessor.
                Including preprocessing as part of the syntax tree ensures that there aren't syntax errors hiding in unused code branches.
                Constant values can be overridden at compile time using a command-line argument such as <span class="chunk">"--define:TRACE=true"</span>.
              </p>
              <pre class="skew">if TRACE {
  const traceEnter = (label string) => {
    Log.info("[enter] " + label)
    Log.indent++
  }

  const traceLeave = (label string) => {
    Log.indent--
    Log.info("[leave] " + label)
  }
}

else {
  def traceEnter(label string) {}
  def traceLeave(label string) {}
}

const TRACE = false</pre>
              <p>
                The compiler includes some predefined variables that are automatically set based on the compilation settings.
              </p>
              <pre class="skew">if TARGET == .CSHARP {
  class ParseError : System.Exception {}
} else {
  class ParseError {}
}</pre>
              <p>
                Another form of conditional compilation is the "@skip" annotation.
                Annotating something with "@skip" means that all call sites and their argument evaluations will be removed at compile time and will not be present in the output.
                This is cleaner and less error-prone than using top-level if statements for conditional compilation of functions because all uses are type-checked even when unused.
              </p>
              <pre class="skew"># Any annotation can be applied conditionally using the
# post-if syntax. The condition must be a compile-time
# constant just like for top-level if statements.
@skip if RELEASE
def debugLog(text string) {
  dynamic.console.log(text)
}

@export
def sum(x int, y int) int {
  if x + y &lt; 0 {
    debugLog("warning: " + x.toString + " + " + y.toString + " &lt; 0")
  }
  return x + y
}</pre>
              <p>
                The code above becomes this JavaScript code in debug mode:
              </p>
              <pre class="js">(function() {
  // Any annotation can be applied conditionally using the
  // post-if syntax. The condition must be a compile-time
  // constant just like for top-level if statements.
  function debugLog(text) {
    console.log(text);
  }

  sum = function(x, y) {
    if ((x + y | 0) &lt; 0) {
      debugLog('warning: ' + x.toString() + ' + ' + y.toString() + ' &lt; 0');
    }

    return x + y | 0;
  };
})();</pre>
              <p>
                ...and this in release mode:
              </p>
              <pre class="js">(function(){sum=function(a,b){return a+b|0}})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Lambda expressions</button>
            <div class="reveal">
              <p>
                Lambda expressions are lexical closures, meaning they have mutable access to the symbols they close over.
                Regular functions declared using "def" are not lambda expressions and cannot be casted to a lambda type since they are not represented as objects in some language targets.
                The argument and/or return types can be omitted when they can be inferred from context.
              </p>
              <pre class="skew">@entry
def main {
  # These are all equivalent
  var zero1 = => 0
  var zero2 = () => 0
  var zero3 = () int => 0
  var zero4 = () int => { return 0 }

  # These are both equivalent
  var add1 = (x int, y int) => 0
  var add2 fn(int, int) int = (x, y) => 0
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Generics with type erasure</button>
            <div class="reveal">
              <p>
                Type erasure is beneficial in a web environment because it generates compact code, which improves both network transfer time and JIT warmup time.
                Generics do not currently support type inference.
              </p>
              <pre class="skew">class Pair&lt;A, B> {
  const first A
  const second B
}

@export
def pack&lt;A, B>(first A, second B) Pair&lt;A, B> {
  return Pair&lt;A, B>.new(first, second)
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Type inference</button>
            <div class="reveal">
              <p>
                Types can often be inferred from context, which avoids the need to repeat redundant type declarations.
                Variable types are optional but function signatures are required to avoid harming API readability.
              </p>
              <pre class="skew">enum Demo {
  DEMO
}

@export
def main {
  # Without type inference
  var lambda fn(int, int) int = (x int, y int) int => x + y
  var demo Demo = Demo.DEMO
  var list List&lt;int> = [1, 2, 3]
  var map StringMap&lt;int> = {"a": 1, "b": 2}

  # With type inference
  lambda = (x, y) => x + y
  demo = .DEMO
  list = [1, 2, 3]
  map = {"a": 1, "b": 2}
}</pre>
            </div>
          </li>
        </ul>

        <p>
          Compiler optimizations:
        </p>

        <ul>
          <li class="expandable">
            <button>JavaScript syntax tree compaction</button>
            <div class="reveal">
              <p>
                The compiler uses a complex lattice of rules to compact the generated JavaScript code in release mode similar to the advanced compilation mode in Google Closure Compiler.
                However, the compiler can often do slightly better than Google's compiler due to certain language features (explicit integer types, for example).
                This reduces application startup time by transferring less data over the network.
              </p>
              <pre class="skew">enum Type {
  RADIANS
  DEGREES
  SECONDS
  METERS
}

@export
def format(type Type, value double) string {
  if type == .DEGREES || type == .RADIANS {
    if type == .RADIANS {
      value *= 180 / Math.PI
    }
    return value.toString + "deg"
  }
  if type == .SECONDS {
    return value.toString + "s"
  }
  assert(type == .METERS)
  return value.toString + "m"
}
</pre>
              <p>
                The code above reduces down to this JavaScript code in release mode:
              </p>
              <pre class="js">(function(){format=function(a,b){return a==1||!a?(a||(b*=57.29577951308232),b+'deg'):b+(a^2?'m':'s')}})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Symbol renaming</button>
            <div class="reveal">
              <p>
                The compiler includes a global symbol motion and renaming pass in release mode to reduce symbol name length similar to the advanced compilation mode in Google Closure Compiler.
                Namespace nesting is removed and symbols are renamed to the shortest possible names using frequency analysis.
                Unrelated properties and local variables can reuse the same names, which makes those names even more common and easier for gzip to compress.
                This reduces application startup time by transferring less data over the network.
                It also serves as a form of obfuscation if you care about that sort of thing.
                Renaming is not done for symbols with an "@import" or "@export" annotation and for names accessed off of the special "dynamic" type.
              </p>
              <pre class="skew">namespace Demo {
  class Vector {
    var x double
    var y double
  }

  class Rect {
    var lower Vector
    var upper Vector

    def area double {
      return (upper.x - lower.x) * (upper.y - lower.y)
    }

    def include(x double, y double) {
      lower.x = Math.min(lower.x, x)
      lower.y = Math.min(lower.y, y)
      upper.x = Math.max(upper.x, x)
      upper.y = Math.max(upper.y, y)
    }
  }

  namespace Rect {
    def empty Rect {
      return new(
        Vector.new(Math.INFINITY, Math.INFINITY),
        Vector.new(-Math.INFINITY, -Math.INFINITY))
    }
  }
}

@export
def demo {
  var rect = Demo.Rect.empty
  for i in 0..100 {
    rect.include(Math.random, Math.random)
  }
  console.log(rect.area)
}

@import
const console dynamic</pre>
              <p>
                The code above becomes this JavaScript code in release mode.
                Notice how the properties for both "Rect" and "Vector" can reuse the same names because they are two unrelated types:
              </p>
              <pre class="js">(function(){demo=function(){for(var a=new i(new h(Infinity,Infinity),new h(-Infinity,-Infinity)),b=0;b&lt;100;++b)f(a,Math.random(),Math.random());console.log(e(a))};function e(a){return (a.b.a-a.a.a)*(a.b.b-a.a.b)}function f(c,a,b){c.a.a=Math.min(c.a.a,a),c.a.b=Math.min(c.a.b,b),c.b.a=Math.max(c.b.a,a),c.b.b=Math.max(c.b.b,b)}function h(a,b){this.a=a,this.b=b}function i(a,b){this.a=a,this.b=b}})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Function inlining</button>
            <div class="reveal">
              <p>
                The compiler currently inlines simple functions where the body consists of a single expression statement or return statement and where each argument is used once.
              </p>
              <pre class="skew">class CheckedValue&lt;T> {
  var _value T
  var _check fn(T) bool

  def value T {
    return _value
  }

  def value=(value T) {
    assert(_check(value))
    _value = value
  }
}

@entry
def main {
  var length = CheckedValue&lt;int>.new(0, x => {
    return x >= 0
  })
  length.value = length.value + 100
}</pre>
              <p>
                The code above becomes this JavaScript code in release mode:
              </p>
              <pre class="js">(function(){function e(){var a=new d(0,function(b){return b>-1});a.a=a.a+100|0}function d(a,b){this.a=a,this.b=b}e()})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Constant folding</button>
            <div class="reveal">
              <p>
                Constant folding does partial evaluation of the code at compile-time.
                This often opens up opportunities for further optimizations such as dead code elimination inside the "else" branch of an "if true" statement.
                Constant folding works well in combination with with function inlining.
              </p>
              <pre class="skew">const COLOR = rgba(127, 255, 0, 255)

def rgba(r int, g int, b int, a int) int {
  return (r &amp; 255) &lt;&lt; 24 | (g &amp; 255) &lt;&lt; 16 | (b &amp; 255) &lt;&lt; 8 | (a &amp; 255)
}

@export
def demo {
  if COLOR == 0x7FFF00FF {
    dynamic.console.log(COLOR)
  }
}</pre>
              <p>
                The code above becomes this JavaScript code in release mode:
              </p>
              <pre class="js">(function(){demo=function(){console.log(2147418367)}})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Tree shaking</button>
            <div class="reveal">
              <p>
                The compiler starts from functions with the "@export" and "@entry" annotations and finds all transitive dependencies.
                Any code that wasn't reached is treated as dead and removed from the output.
                This reduces application startup time by transferring less data over the network.
                This is also enabled in debug mode because lots of extra unused library code makes debugging harder.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>Devirtualization</button>
            <div class="reveal">
              <p>
                Virtual functions have overhead, mostly because they prevent inlining.
                Devirtualization detects functions that are unnecessarily virtual and rewrites them to global functions instead, which can then be optimized further.
                It is why function inlining works on instance functions.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>Interface removal</button>
            <div class="reveal">
              <p>
                Interfaces that only have one implementation can be safely replaced with that implementation.
                This opens up more optimization opportunities such as devirtualization and inlining.
              </p>
            </div>
          </li>
        </ul>

        <h3 id="why">Why use it?</h3>

        <p>
          The intent is to use this language for the platform-independent stuff in an application and to use the language native to the target platform for the platform-specific stuff.
          When done properly, the vast majority of the code is completely platform-independent and new platforms can be targeted easily with a small platform-specific shim.
        </p>

        Pros:

        <ul class="padded">
          <li>
            <b>Advanced optimizations:</b>
            The optimizations in the compiler combined with certain language features (integers, explicit exports, wrapped types, etc.) makes writing compact, efficient JavaScript code easy and pleasant.</li>
          <li>
            <b>Fast compile times:</b>
            Code compiles at the speed of a browser refresh.
            Web development still feels like web development despite using an optimizing compiler with static typing.
            This is in contrast to many other comparable compile-to-JavaScript languages.
          </li>

          <li>
            <b>Natural debugging experience:</b>
            Debugging is done in a single language using the platform-native debugger.
            No need to try to debug a multi-language app with a debugger that only understands one language.
          </li>

          <li>
            <b>Easy integration:</b>
            Generated code is very readable and closely corresponds with the original.
            Language features allow for the easy import and export of code to and from the target language.
          </li>

          <li>
            <b>Fast iteration time:</b>
            In addition to a fast compiler and a good debugging experience, garbage collection is used instead of manual memory management.
            This eliminates a whole class of time-consuming bugs that get in the way of the important stuff.
          </li>

          <li>
            <b>Native code emission:</b>
            For native targets, application logic is compiled directly to native code and is not interpreted in a virtual machine.
            Native apps don't have to pay for JIT warmup time and native app performance is not at the whim of heuristics.
            The generated code can be compiled using industry-standard compilers that leverage decades of optimization work.
          </li>
        </ul>

        Cons:

        <ul class="padded">
          <li>
            <b>Lack of IDE support:</b>
            IDE support is planned but is a significant undertaking and will not materialize for a while.
            Developers who normally lean heavily on IDEs will be less efficient than usual.
          </li>

          <li>
            <b>Immaturity:</b>
            This is a new programming language and hasn't stood the test of time.
            There will likely be many rough edges both in the language design and in the tools.
            Many planned features are not yet implemented.
          </li>

          <li>
            <b>Lack of community:</b>
            New programming languages don't have the wealth of searchable Q&amp;A data that established programming languages have.
            Solutions to random issues are likely not available online.
          </li>

          <li>
            <b>No cross-platform multithreading:</b>
            Multithreading is not a language feature and needs to be done in the target language.
            This limits multithreading opportunities to cleanly separable tasks like image decoding.
          </li>

          <li>
            <b>Lack of low-level features:</b>
            Features such as memory layout, move semantics, destructors, and vector instructions are intentionally omitted.
            These features don't map well to all language targets and their emulation is expensive.
            Use of these features is limited to imported library routines implemented in the target language.
          </li>
        </ul>

        <h3 id="start">Getting Started</h3>

        <p>
          The compiler is currently published on <a href="https://www.npmjs.com/package/skew">npm</a>, the package manager for <a href="https://nodejs.org/">node</a>.
          It's simplest to install it globally:
        </p>
        <pre>npm install -g skew</pre>
        <p>
          The compiler command is called "skewc".
          Run "skewc --help" to see a list of all available command-line flags.
          Example usage:
        </p>
        <pre>skewc src/*.sk --output-file=compiled.js --target=js --release</pre>
        <p>
          Simple examples to start from:
        </p>
        <ul>
          <li class="expandable">
            <button>Example browser app</button>
            <div class="reveal">
              <p>
                Create a file called "sparks.sk" that looks like this:
              </p>
              <pre class="skew">@entry
def main {
  var canvas = document.createElement("canvas")
  var context = canvas.getContext("2d")
  var sparks List&lt;Spark> = []
  var tick fn()

  document.onmousemove = (e dynamic) => {
    sparks.append(Spark.new(
      e.pageX - canvas.offsetLeft,
      e.pageY - canvas.offsetTop,
      Math.random * 20 - 10,
      Math.random * -40))
  }

  tick = => {
    canvas.width = 640
    canvas.height = 480
    canvas.style.background = "#EEE"
    context.beginPath()
    sparks.removeIf(s => {
      s.x += s.vx / 2
      s.y += s.vy / 2
      s.vy += 3
      s.time -= 1.0 / 60
      context.moveTo(s.x, s.y)
      context.lineTo(s.x + s.vx, s.y + s.vy)
      return s.time &lt; 0
    })
    context.stroke()
    requestAnimationFrame(tick)
  }

  document.body.appendChild(canvas)
  tick()
}

class Spark {
  var x double
  var y double
  var vx double
  var vy double
  var time = 1.0
}

@import {
  const document dynamic
  def requestAnimationFrame(callback fn())
}</pre>
              <p>
                Invoke the compiler to generate JavaScript code.
                Any compilation errors will show up here:
              </p>
              <pre>skewc sparks.sk --output-file=sparks.js --target=js</pre>
              <p>
                Create another file called "index.html" to serve the compiled code:
              </p>
              <pre class="skew">&lt;body>&lt;/body>
&lt;script src="sparks.js">&lt;/script></pre>
              <p>
                That's it!
                Open "index.html" in a browser to see the app.
                To build a production-ready version of your app, just add the <span class="chunk">"--release"</span> flag to the end of the compiler invocation:
              </p>
              <pre>skewc sparks.sk --output-file=sparks.js --target=js --release</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Example command-line app</button>
            <div class="reveal">
              <p>
                Create a file called "calculator.sk" that looks like this:
              </p>
              <pre class="skew">@entry
def main {
  var example = "(1 + 2) * 3"
  var readline = require("readline").createInterface({
    "input": process.stdin,
    "output": process.stdout,
  })
  var question fn()
  var answer = (text string) => {
    var tokens = text.split(RegExp.new("(\\d+|[()+\\-*/])"))
    var output List&lt;double> = []
    var stack List&lt;int> = []
    var priority = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 3}
    var binary = (callback fn(double, double) double) => {
      var right = output.takeLast
      var left = output.takeLast
      output.append(callback(left, right))
    }
    tokens.append("\0")
    for i in 0..tokens.count {
      if i % 2 == 0 { continue }
      var op = tokens[i][0]
      switch op {
        case '+', '-', '*', '/', '(', ')', '\0' {
          var p = priority.get(op, 0)
          while !stack.isEmpty &amp;&amp; priority.get(stack.last, 3) > p {
            switch stack.last {
              case '+' { binary((a, b) => a + b) }
              case '-' { binary((a, b) => a - b) }
              case '*' { binary((a, b) => a * b) }
              case '/' { binary((a, b) => a / b) }
              case '(' { if op != ')' { break } }
              default { break }
            }
            if stack.takeLast == '(' { break }
          }
          if op != ')' &amp;&amp; op != '\0' { stack.append(op) }
        }
        default { output.append(parseFloat(tokens[i])) }
      }
    }
    console.log("answer: " + output.first.toString)
    question()
  }
  question = => readline.question("> ", answer)
  console.log("> " + example)
  answer(example)
}

@import {
  const console dynamic
  const process dynamic
  const RegExp dynamic
  def parseFloat(text string) double
  def require(name string) dynamic
}</pre>
              <p>
                Invoke the compiler to generate JavaScript code.
                Any compilation errors will show up here:
              </p>
              <pre>skewc calculator.sk --output-file=calculator.js --target=js</pre>
              <p>
                That's it!
                Run "node calculator.js" to see the app.
              </p>
            </div>
          </li>
        </ul>
        <p>
          All of these examples use the "dynamic" type for simplicity, but you'll likely want type imports for real work.
          Skew will eventually have a package manager and type imports will live there.
          I've put some <a href="https://github.com/evanw/skew-imports/tree/master/html5">HTML5 type imports</a> on GitHub for convenience in the meantime.
        </p>
        <p>
          IDE support:
        </p>
        <ul class="padded">
          <li>
            <a href="http://www.sublimetext.com/">Sublime Text</a><br>
            Follow <a href="https://github.com/evanw/skew/tree/master/extras/Sublime%20Text">these instructions</a> to install syntax highlighting.
          </li>
          <li>
            <a href="https://atom.io/">Atom</a><br>
            Install the <a href="https://atom.io/packages/skew">skew</a> package for syntax highlighting.
            This also adds rudimentary IDE support that includes inline errors and type tooltips on hover.
            Use the
            <script>document.write(navigator.platform === 'MacIntel' ? '"\u2318;"' : '"Ctrl+;"')</script>
            shortcut to open the diagnostics panel.
            IDE features currently only update when the file is saved.
          </li>
        </ul>

        <h3 id="docs">Documentation</h3>

        <p>
          Language reference:
        </p>
        <ul>
          <li class="expandable">
            <button>Variables</button>
            <div class="reveal">
              <p>
                Variables are declared with the "var" keyword and the type comes after the variable name.
                If the type is omitted, the type is inferred from the assigned value.
                Read-only variables are declared with the "const" keyword.
              </p>
              <pre class="skew">var explicitlyTyped int = 0
var implicitlyTyped = 0
const readOnly = 0</pre>
              <p>
                Constant values can be overridden at compile time using the <span class="chunk">"--define"</span> flag.
                For example, the flag <span class="chunk">"--define:readOnly=1"</span> would cause "readOnly" to be initialized to 1 instead of 0 in the code above.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>Functions</button>
            <div class="reveal">
              <p>
                Functions are declared with the "def" keyword.
                Parentheses are not used for functions that don't take any arguments, both when declaring the function and when calling it.
                Absence of a return type is indicated by just not specifying a return type instead of requiring a special "void" type as other languages like C do.
                Function declaration order doesn't matter.
              </p>
              <pre class="skew">def test {
  withoutArguments
  withArguments(1, 2, 3)
  overloaded(123)
  overloaded("text")
}

def withoutArguments int { return 0 }
def withArguments(x int, y int, z int) int { return 0 }
def overloaded(x int) {}
def overloaded(x string) {}</pre>
              <p>
                Abstract and imported functions cannot be implemented and are declared by omitting the body:
              </p>
              <pre class="skew">@import
def print(text string)

def test {
  print("works")
}</pre>
              <p>
                Setter-style functions are declared by adding a "=" to the end of the function name:
              </p>
              <pre class="skew">def test {
  setter = 0
}

def setter=(x int) {}</pre>
              <p>
                Multiple declarations can exist for the same function, although there can only be one implementation.
                This is sometimes useful when organizing code for clarity and is especially useful when combined with conditional compilation.
                It's sort of comparable to forward declarations in C/C++ although they are order-independent and don't need to come first.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>If-else statements</button>
            <div class="reveal">
              <p>
                Unlike in C, all conditional statements omit the parentheses surrounding the condition and require braces.
              </p>
              <pre class="skew">def test(a bool, b bool) {
  if a {}
  else if b {}
  else {}
}</pre>
              <p>
                C-style conditional expressions are supported.
              </p>
              <pre class="skew">def test(a bool) int {
  return a ? 1 : 2
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Loop statements</button>
            <div class="reveal">
              <p>
                Different loop types:
              </p>
              <pre class="skew">def test {
  # While loop
  var a = 0
  while a &lt; 5 { a++ }

  # Range for loop (lower inclusive, upper exclusive)
  for b in 0..5 {}

  # C-style for loop
  for c = 0; c &lt; 5; c++ {}

  # For-in loop (currently only for List&lt;T>)
  for d in [1, 2, 3, 4, 5] {}
}</pre>
              <p>
                Loop control flow is done using the "break" and "continue" keywords as in C.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>Switch statements</button>
            <div class="reveal">
              <p>
                Switch statements look more like other statements than they do in C.
                The fallthrough feature of C-style switch statements was deliberately removed.
              </p>
              <pre class="skew">def test(x int) bool {
  switch x {
    case 1, 2, 3 { return true }
    case 4, 5 { return false }
    default { return x > 0 }
  }
}</pre>
              <p>
                Unlike in C, the "break" keyword is only for use with loops.
                Using a break inside a "case" block will break from the enclosing loop.
              </p>
              <pre class="skew">def validateEscapes(text string) bool {
  var slash = false
  for i in 0..text.count {
    switch text[i] {
      case '\\' { slash = !slash }
      case 'n', 't' { slash = false }
      default { if slash { break } } # Here "break" stops the loop
    }
  }
  return !slash
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Return statements</button>
            <div class="reveal">
              <p>
                One unusual thing about return statements is the handling of return statements where the value is on the next line.
                This case is trivial in semicolon-terminated languages like C because the value comes before the semicolon.
                In languages like JavaScript, automatic semicolon insertion gets in the way and causes the code to behave incorrectly (return undefined instead of the value).
                Skew doesn't have semicolons or automatic semicolon insertion and so doesn't suffer from this issue.
                In Skew, an expression following a return statement is considered to be the returned value if the return statement is inside a function with non-empty a return type.
              </p>
              <pre class="skew"># This function returns "int" so the value is returned
def add(a int, b int) int {
  return
    a + b
}

# This function returns nothing so the value is ignored
def subtract(a int, b int) {
  return
  a - b # warning: Unused expression
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Lambda expressions</button>
            <div class="reveal">
              <p>
                Lambda expressions are lexical closures, meaning they have mutable access to the symbols they close over.
                Regular functions declared using "def" are not lambda expressions and cannot be casted to a lambda type since they are not represented as objects in some language targets.
                The argument and/or return types can be omitted when they can be inferred from context.
              </p>
              <pre class="skew">def test {
  # These are all equivalent
  var zero1 = => 0
  var zero2 = () => 0
  var zero3 = () int => 0
  var zero4 = () int => { return 0 }

  # These are both equivalent
  var add1 = (x int, y int) => 0
  var add2 fn(int, int) int = (x, y) => 0
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Classes and interfaces</button>
            <div class="reveal">
              <p>
                Skew's object model is similar to Java.
                A class can inherit from at most one base class and can implement any number of interfaces.
                The symbols ":" and "::" are used instead of the "extends" and "implements" keywords.
              </p>
              <p>
                Unlike Java, all type declarations are "open", which means members from duplicate type declarations for the same type are all merged together at compile time into a single type.
                This allows for large type declarations to be better organized and also allows for safe compile-time monkey patching.
                In the example below, the "ChunkedBuffer" type can be made to implement the "Encoder" interface using a separate declaration.
              </p>
              <pre class="skew">class Buffer {
  var data = ""
  def append(data string) { self.data += data }
}

class ChunkedBuffer : Buffer {
  over append(data string) { self.data += "[" + data + "]" }
}

interface Encoder {
  def encodeInt(value int)
  def encodeString(value string)
}

class ChunkedBuffer :: Encoder {
  def encodeInt(value int) { append(value.toString) }
  def encodeString(value string) { append(value) }
}

class User {
  var id int
  var name string

  def encode(encoder Encoder) {
    encoder.encodeInt(id)
    encoder.encodeString(name)
  }
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Constructors</button>
            <div class="reveal">
              <p>
                A constructor is a function called "new" with no return type.
                Constant instance variables can only be assigned to in a constructor.
              </p>
              <pre class="skew">class Node {
  var weight int
  var children List&lt;Node>

  def new(children List&lt;Node>) {
    weight = 0
    self.children = children
  }
}

class NamedNode : Node {
  const name string

  def new(children List&lt;Node>, name string) {
    super(children)
    self.name = name
  }
}</pre>
              <p>
                When not explicitly declared, constructors are automatically generated with one argument for each instance variable without a default value in declaration order.
                This greatly simplifies defining objects in many situations.
                For example, the above code can be simplified to the code below since both constructors can be generated automatically:
              </p>
              <pre class="skew">class Node {
  var weight = 0
  var children List&lt;Node>
}

class NamedNode : Node {
  const name string
}</pre>
              <p>
                Unlike Java, constructors are just members of the type they construct and don't require a special operator to invoke:
              </p>
              <pre class="new">def createTree Node {
  return Node.new([
    NamedNode.new([], "X"),
    NamedNode.new([], "Y"),
  ])
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Enums</button>
            <div class="reveal">
              <p>
                An enum is a compile-time integer constant.
                Enums automatically convert to ints but ints don't automatically convert to enums.
                When referencing an enum value, the enum type can be omitted when it can be inferred from context.
                This leaves just a leading "." character.
              </p>
              <pre class="skew">class Entry {
  enum Kind {
    FILE
    DIRECTORY
  }

  const kind Kind
  const children List&lt;Entry>
}

def visitFiles(entry Entry, visitor fn(Entry)) {
  switch entry.kind {
    case .FILE { # Could also be "case Entry.Kind.FILE"
      visitor(entry)
    }

    case .DIRECTORY { # Could also be "case Entry.Kind.DIRECTORY"
      for child in entry.children {
        visitFiles(child, visitor)
      }
    }
  }
}</pre>
              <p>
                For convenience, each enum type automatically generates a "toString" function if one isn't present.
                Enums can have instance functions just like any other object type (they are automatically rewritten as global functions during compilation that take the enum as an extra first argument).
              </p>
              <pre class="skew">enum Demo {
  A
  B
  C

  def log {
    print(toString)
  }
}

def test {
  Demo.A.log # This prints "A"
}

@import
def print(text string)</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Casting</button>
            <div class="reveal">
              <p>
                Casting is done using the "as" operator.
                These are useful for converting between primitive types and also for downcasting from a base class to a derived class.
                Downcasts are unchecked and have no performance impact in dynamic language targets, where they disappear entirely.
              </p>
              <pre class="skew">class Base {}
class Derived : Base {}

def test {
  var truncated = 3.5 as int
  var base Base = Derived.new
  var downcasted = base as Derived
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Try/catch/finally/throw statements</button>
            <div class="reveal">
              <p>
                These function similar to other languages.
              </p>
              <pre class="skew">def test {
  try {
    switch (Math.random * 3) as int {
      case 0 { throw A.new }
      case 1 { throw B.new }
      case 2 { throw C.new }
    }
  }
  catch temp A {} # This will only catch "A"
  catch temp B {} # This will only catch "B"
  finally {} # "C" is never caught and will propagate upwards
}

class A {}
class B {}
class C {}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Protected access</button>
            <div class="reveal">
              <p>
                Names that start with "_" have protected access.
                They are only available to that class and its derived classes.
              </p>
              <pre class="skew">class Test {
  var _value = 0

  def test {
    _value++ # This works fine
  }
}

def main {
  Test.new._value++ # This causes a compile error
}</pre>
              <p>
                Protected access works for any named scope including namespaces and interfaces.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>Namespace merging (a.k.a. "static" members)</button>
            <div class="reveal">
              <p>
                All variables and functions inside a class declaration are attached to instances of that class.
                To scope global variables and functions inside the class name, put them inside a namespace with the same name as the class.
                This does what the "static" keyword does in many other languages.
              </p>
              <pre class="skew">class Demo {
  var instanceVariable = 0
  def instanceFunction {}
}

namespace Demo {
  var globalVariable = 0
  def globalFunction {}
}

def test {
  Demo.new.instanceVariable
  Demo.new.instanceFunction
  Demo.globalVariable
  Demo.globalFunction
}</pre>
              <p>
                This works for all types with instances including enums and interfaces.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>Generics</button>
            <div class="reveal">
              <p>
                Generics are implemented using type erasure to ensure a compact and readable implementation in the generated code.
                The current implementation is pretty simple.
                There isn't any type inference yet, and also no advanced features like covariant and contravariant conversions.
              </p>
              <pre class="skew">class Pair&lt;A, B> {
  const first A
  const second B
}

@export
def pack&lt;A, B>(first A, second B) Pair&lt;A, B> {
  return Pair&lt;A, B>.new(first, second)
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Operator overloading</button>
            <div class="reveal">
              <p>
                The compiler checks for operators on the first operand.
                Operator overloading can make code more readable in many cases, but can also dramatically reduce readability when used incorrectly.
                Use with good judgement.
              </p>
              <pre class="skew">enum Axis {
  X
  Y
}

class Vector {
  var x double
  var y double

  def -(p Vector) Vector {
    return Vector.new(x - p.x, y - p.y)
  }

  def [](a Axis) double {
    return a == .X ? x : y
  }

  def []=(a Axis, v double) {
    if a == .X { x = v }
    else { y = v }
  }
}

class Player {
  var position Vector

  def deltaTo(other Player) Vector {
    return other.position - position
  }

  def moveAlongAxis(axis Axis, delta double) {
    position[axis] = position[axis] + delta
  }
}</pre>
              <p>
                The "in" operator is a special case.
                It looks for operators on the second operand instead of the first operand since that allows it to work with generic types:
              </p>
              <pre class="skew">class Container&lt;T> {
  def in(value T) bool
  def add(value T)
}

def addIfMissing&lt;T>(value T, container Container&lt;T>) {
  if !(value in container) {
    container.add(value)
  }
}</pre>
              <p>
                Another interesting operator is the "&lt;=>" comparison operator.
                It returns an integer that is less than zero if the first operand is less than the second, greater than zero if the first operand is greater than the second, and zero if the first operand is equal to the second.
                It is used by the compiler to automatically implement the "&lt;", ">", "&lt;=", and ">=" operators, which cannot be implemented manually.
              </p>
              <pre class="skew">class Point {
  var x int
  var y int

  def &lt;=>(p Point) int {
    var delta = x &lt;=> p.x
    return delta != 0 ? delta : y &lt;=> p.y
  }
}

def test(list List&lt;Point>) {
  list.sort((a, b) => a &lt;=> b)
  var zero = Point.new(0, 0)
  list.removeIf(p => p &lt; zero)
}</pre>
              <p>
                There are also special operators that allow the type to integrate with list and map literals.
                The simplest way of doing this is with special constructors called "[new]" and "{new}" that take lists as arguments.
                The compiler puts all expressions inside the list or map literal in a list and passes it to the constructor.
              </p>
              <pre class="skew">class DemoList&lt;T> {
  def [new](values List&lt;T>) {}
}

class DemoMap&lt;K, V> {
  def {new}(keys List&lt;K>, values List&lt;V>) {}
}

@entry
def test {
  var list DemoList&lt;int> = [1, 2, 3]
  var map DemoMap&lt;int, int> = {1: 2, 3: 4}
}</pre>
              <p>
                The more flexible way of doing this is with the special "[...]" and "{...}" instance functions.
                The compiler constructs a new object of that type and builds a chain of calls to those special instance functions with one call for each element in the list or map literal.
                This allows the type to support different types of values in the same literal.
              </p>
              <pre class="skew">class DemoList {
  def [...](value int) DemoList { return self }
  def [...](value string) DemoList { return self }
}

class DemoMap {
  def {...}(key int, value int) DemoMap { return self }
  def {...}(key string, value string) DemoMap { return self }
}

@entry
def test {
  var list DemoList = [1, "2"]
  var map DemoMap = {1: 2, "3": "4"}
}</pre>
              <p>
                The "==" and "!=" operators cannot be overloaded since they test for reference equality and need to handle implicit bidirectional type conversions.
                The "&amp;&amp;" and "||" operators cannot be overloaded because of their special short-circuit evaluation behavior.
                The "=" operator cannot be overridden since that's too confusing in a language that lacks value types.
                If the "=" were overridable, objects would then be copied on assignment but would be passed by reference as arguments to function calls.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>Wrapped types</button>
            <div class="reveal">
              <p>
                Wrapped types are defined using the "type" keyword.
                They must be explicitly casted, which can be used to improve type safety.
              </p>
              <pre class="skew">type CSV = string

@export
def escapeForCSV(text string) CSV {
  if "\"" in text || "," in text || "\n" in text {
    return ("\"" + text.replaceAll("\"", "\"\"") + "\"") as CSV
  }
  return text as CSV
}</pre>
              <p>
                Wrapped types can also be used to add encapsulation without the overhead of additional allocation.
                Instance functions added to wrapped types are automatically rewritten as global functions during compilation that take the instance as an extra first argument.
              </p>
              <pre class="skew">type Color : int {
  def r int { return (self as int) &amp; 255 }
  def g int { return ((self as int) >> 8) &amp; 255 }
  def b int { return ((self as int) >> 16) &amp; 255 }
  def a int { return (self as int) >>> 24 }

  def opaque Color {
    return new(r, g, b, 255)
  }
}

namespace Color {
  def new(r int, g int, b int, a int) Color {
    return (r | g &lt;&lt; 8 | b &lt;&lt; 16 | a &lt;&lt; 24) as Color
  }
}

@export
def isOrange(color Color) bool {
  return color.opaque == Color.new(255, 127, 0, 255)
}</pre>
              <p>
                The code above becomes this JavaScript code in release mode:
              </p>
              <pre class="js">(function(){isOrange=function(a){return b(a)==-16744449};function b(a){return a|-16777216}})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Conditional compilation</button>
            <div class="reveal">
              <p>
                Top-level if statements allow for conditional code compilation.
                Like all declarations, top-level if statements are also order-independent and are evaluated from the outside in.
                Conditions must be compile-time constants but are fully type-checked, unlike the C preprocessor.
                Including preprocessing as part of the syntax tree ensures that there aren't syntax errors hiding in unused code branches.
                Constant values can be overridden at compile time using a command-line argument such as <span class="chunk">"--define:TRACE=true"</span>.
              </p>
              <pre class="skew">if TRACE {
  const traceEnter = (label string) => {
    Log.info("[enter] " + label)
    Log.indent++
  }

  const traceLeave = (label string) => {
    Log.indent--
    Log.info("[leave] " + label)
  }
}

else {
  def traceEnter(label string) {}
  def traceLeave(label string) {}
}

const TRACE = false</pre>
              <p>
                The compiler includes some predefined variables that are automatically set based on the compilation settings.
              </p>
              <pre class="skew">if TARGET == .CSHARP {
  class ParseError : System.Exception {}
} else {
  class ParseError {}
}</pre>
              <p>
                Another form of conditional compilation is the "@skip" annotation.
                Annotating something with "@skip" means that all call sites and their argument evaluations will be removed at compile time and will not be present in the output.
                This is cleaner and less error-prone than using top-level if statements for conditional compilation of functions because all uses are type-checked even when unused.
              </p>
              <pre class="skew"># Any annotation can be applied conditionally using the
# post-if syntax. The condition must be a compile-time
# constant just like for top-level if statements.
@skip if RELEASE
def debugLog(text string) {
  dynamic.console.log(text)
}

@export
def sum(x int, y int) int {
  if x + y &lt; 0 {
    debugLog("warning: " + x.toString + " + " + y.toString + " &lt; 0")
  }
  return x + y
}</pre>
              <p>
                The code above becomes this JavaScript code in debug mode:
              </p>
              <pre class="js">(function() {
  // Any annotation can be applied conditionally using the
  // post-if syntax. The condition must be a compile-time
  // constant just like for top-level if statements.
  function debugLog(text) {
    console.log(text);
  }

  sum = function(x, y) {
    if ((x + y | 0) &lt; 0) {
      debugLog('warning: ' + x.toString() + ' + ' + y.toString() + ' &lt; 0');
    }

    return x + y | 0;
  };
})();</pre>
              <p>
                ...and this in release mode:
              </p>
              <pre class="js">(function(){sum=function(a,b){return a+b|0}})();</pre>
            </div>
          </li>

          <li class="expandable">
            <button>The "dynamic" type</button>
            <div class="reveal">
              <p>
                There is a special type called "dynamic" that tells the compiler to ignore type errors and pass all dynamically-typed code through verbatim to the target language.
                It is mainly useful when interacting with external code, especially when targeting a dynamic language.
              </p>
              <p>
                Simple example:
              </p>
              <pre class="skew">@import
const console dynamic

def main {
  console.log("works")
}</pre>
              <p>
                The "dynamic" type poisons everything it touches.
                For example, "1 + x" has a dynamic type if "x" is dynamic because the compiler can't tell what type the expression will be ("x" could hold an int, a double, a string, or even something nonsensical like an object).
                This makes it easy to bypass the compiler's type system by casting the value to the "dynamic" type first.
              </p>
              <p>
                Pros:
              </p>
              <ul>
                <li>Makes it easy to import large libraries without tons of type declarations.</li>
                <li>
                  Provides a way to bypass compiler checks when there's a type system mismatch with the target language.
                  For example, C# supports "in" and "out" modifiers on generic type parameters and Skew does not.
                </li>
                <li>Used by the compiler to silence further errors when an error occurs during compilation (expressions with compile errors always have type "dynamic").</li>
              </ul>
              <p>
                Cons:
              </p>
              <ul>
                <li>Mistakes cause run-time errors instead of compile-time errors.</li>
                <li>
                  Most compiler features don't work on dynamically typed code (implicit function calls, operator overloading, function overloading, type wrapping, inlining, constant folding, and so on).
                  Statically-typed values can still be passed through a dynamically-typed environment but must be casted back to their static type before being used or they likely won't work correctly.
                </li>
              </ul>
              <p>
                Values of dynamic type can also be used to emit constructor calls.
                This is done using the "new" property just like for statically-typed objects.
                Notice how function calls in the example below must be explicitly invoked via "()" unlike normal functions.
                This is because the compiler has no type information so it can't distinguish functions from variables.
              </p>
              <pre class="skew">@import
const Object dynamic

def main int {
  return Object.new().toString().length
}</pre>
              <p>
                The keyword "dynamic" can also be used as an expression with a property name following it.
                This causes the following name to be emitted as an identifier with a dynamic type.
                It's mainly useful as an inline shortcut to avoid an imported declaration.
              </p>
              <pre class="skew">class Demo : dynamic.DemoBase {
  def run {
    dynamic.console.log("works")
  }
}</pre>
            </div>
          </li>
        </ul>

        <p>
          Standard library:
        </p>
        <ul>
          <li class="expandable">
            <button>bool</button>
            <div class="reveal">
              <p>
                There are two bool values, "true" and "false".
              </p>
              <pre class="skew">class bool {
  def ! bool
  def toString string
}</pre>
              <p>
                The "&amp;&amp;" and "||" operators also operate on bool values but cannot described using imported functions due to their special short-circuiting behavior.
              </p>
            </div>
          </li>

          <li class="expandable">
            <button>int</button>
            <div class="reveal">
              <p>
                An int is a signed 32-bit non-nullable integer.
                The supported bases are binary (0b101), octal (0o123), decimal (123), and hex (0xABC).
              </p>
              <pre class="skew">class int {
  def + int
  def ++
  def - int
  def --
  def ~ int

  def %(x int) int # Remainder, not modulus (different for negative values)
  def &amp;(x int) int
  def *(x int) int
  def +(x int) int
  def -(x int) int
  def /(x int) int
  def **(x int) int # Exponential operator
  def &lt;&lt;(x int) int
  def &lt;=>(x int) int # Makes "&lt;", ">", "&lt;=", and ">=" work
  def >>(x int) int # Signed shift operator
  def >>>(x int) int # Unsigned shift operator
  def ^(x int) int
  def |(x int) int

  def %=(x int)
  def &lt;=(x int)
  def *=(x int)
  def +=(x int)
  def -=(x int)
  def /=(x int)
  def &lt;&lt;=(x int)
  def >>=(x int) # Signed shift operator
  def >>>=(x int) # Unsigned shift operator
  def ^=(x int)
  def |=(x int)

  def toString string
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>double</button>
            <div class="reveal">
              <p>
                A double is a 64-bit non-nullable floating-point number.
                A number literal must have a "." in it to be a double, otherwise it's an int.
                The non-finite double constants are "Math.NAN" and "Math.INFINITY".
              </p>
              <pre class="skew">class double {
  def + double
  def ++
  def - double
  def --

  def *(x double) double
  def +(x double) double
  def -(x double) double
  def /(x double) double
  def **(x double) double # Exponential operator
  def &lt;=>(x double) int # Makes "&lt;", ">", "&lt;=", and ">=" work

  def *=(x double)
  def +=(x double)
  def -=(x double)
  def /=(x double)

  def isFinite bool
  def isNaN bool
  def toString string
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>string</button>
            <div class="reveal">
              <p>
                A string is an immutable sequence of unicode code units.
                Multi-line strings are allowed.
                String literals must be double-quoted (single quotes are for C-style character literals, which turn into an int with the unicode code point for that character).
                Valid escape sequences are "\0", "\r", "\n", "\t", "\e", "\\", "\"", "\'", and hex-style "\xFF".
              </p>
              <p>
                Strings are stored using the natural string encoding for the target language.
                For example, JavaScript uses UTF-16 and C++ uses UTF-8.
                All indices are in terms of code units since code unit access can be done in constant time.
                To work in platform-independent code points instead, use the code point APIs and Unicode.StringIterator.
              </p>
              <pre class="skew">class string {
  def +(x string) string
  def +=(x string)
  def &lt;=>(x string) int # Makes "&lt;", ">", "&lt;=", and ">=" work

  def count int # Counts code units
  def in(x string) bool # Makes the "x in y" syntax work
  def indexOf(x string) int # Index is in code units
  def lastIndexOf(x string) int # Index is in code units
  def startsWith(x string) bool
  def endsWith(x string) bool

  def [](x int) int # Returns a single code unit
  def get(x int) string # Returns a single code unit
  def slice(start int) string # Slices code units
  def slice(start int, end int) string # Slices code units
  def codePoints List&lt;int>
  def codeUnits List&lt;int>

  def split(x string) List&lt;string>
  def join(x List&lt;string>) string
  def repeat(x int) string
  def replaceAll(before string, after string) string

  def toLowerCase string
  def toUpperCase string
}

namespace string {
  def fromCodePoint(x int) string
  def fromCodePoints(x List&lt;int>) string
  def fromCodeUnit(x int) string
  def fromCodeUnits(x List&lt;int>) string
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>StringBuilder</button>
            <div class="reveal">
              <p>
                In certain language targets, the "+=" operator on strings can be extremely inefficient.
                This API provides an efficient way to construct large strings.
              </p>
              <pre class="skew">class StringBuilder {
  def new
  def append(x string)
  def toString string
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Box&lt;T></button>
            <div class="reveal">
              <p>
                A generic wrapper object for non-nullable types (bool, int, and double) to make them nullable.
                Also useful for nullable types to indicate the absence of a value when null is a valid value.
              </p>
              <pre class="skew">class Box&lt;T> {
  var value T
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>List&lt;T></button>
            <div class="reveal">
              <p>
                Provides a generic array that stores all items linearly in memory.
                List literals are enclosed in square brackets and look like [1, 2, 3].
              </p>
              <pre class="skew">class List&lt;T> {
  def new
  def [...](x T) List&lt;T> # Makes the [1, 2, 3] syntax work

  def [](x int) T
  def []=(x int, y T)

  def count int
  def isEmpty bool
  def resize(count int, defaultValue T)

  def appendOne(x T) # Only append if the value isn't present
  def append(x T)
  def append(x List&lt;T>)

  def prepend(x T)
  def prepend(x List&lt;T>)

  def insert(x int, value T)
  def insert(x int, values List&lt;T>)

  def removeAll(x T)
  def removeAt(x int)
  def removeDuplicates
  def removeFirst
  def removeIf(x fn(T) bool)
  def removeLast
  def removeOne(x T)
  def removeRange(start int, end int)

  def takeFirst T
  def takeLast T
  def takeRange(start int, end int) List&lt;T>

  def first T
  def first=(x T)
  def last T
  def last=(x T)

  def in(x T) bool # Makes the "x in y" syntax work
  def indexOf(x T) int
  def lastIndexOf(x T) int

  def all(x fn(T) bool) bool
  def any(x fn(T) bool) bool
  def clone List&lt;T>
  def each(x fn(T))
  def equals(x List&lt;T>) bool
  def filter(x fn(T) bool) List&lt;T>
  def map&lt;R>(x fn(T) R) List&lt;R>
  def reverse
  def shuffle
  def slice(start int) List&lt;T>
  def slice(start int, end int) List&lt;T>
  def sort(x fn(T, T) int)
  def swap(x int, y int)
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>IntMap&lt;T></button>
            <div class="reveal">
              <p>
                Provides a generic map where reading and writing is done in amortized constant time.
                IntMap literals are enclosed in braces and look like {1: 2, 3: 4}.
              </p>
              <pre class="skew">class IntMap&lt;T> {
  def new
  def {...}(key int, value T) IntMap&lt;T> # Makes the {1: 2} syntax work

  def [](key int) T
  def []=(key int, value T)

  def count int
  def isEmpty bool
  def keys List&lt;int>
  def values List&lt;T>

  def clone IntMap&lt;T>
  def each(x fn(int, T))
  def in(key int) bool # Makes the "x in y" syntax work
  def get(key int, defaultValue T) T
  def remove(key int)
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>StringMap&lt;T></button>
            <div class="reveal">
              <p>
                Provides a generic map where reading and writing is done in amortized constant time.
                StringMap literals are enclosed in braces and look like {"1": 2, "3": 4}.
              </p>
              <pre class="skew">class StringMap&lt;T> {
  def new
  def {...}(key string, value T) StringMap&lt;T> # Makes the {"a": "b"} syntax work

  def [](key string) T
  def []=(key string, value T)

  def count int
  def isEmpty bool
  def keys List&lt;string>
  def values List&lt;T>

  def clone StringMap&lt;T>
  def each(x fn(string, T))
  def get(key string, defaultValue T) T
  def in(key string) bool # Makes the "x in y" syntax work
  def remove(key string)
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Math</button>
            <div class="reveal">
              <pre class="skew">namespace Math {
  const E double
  const INFINITY double
  const NAN double
  const PI double
  const SQRT_2 double

  def abs(x double) double
  def abs(x int) int

  def acos(x double) double
  def asin(x double) double
  def atan(x double) double
  def atan2(x double, y double) double

  def sin(x double) double
  def cos(x double) double
  def tan(x double) double

  def floor(x double) double
  def ceil(x double) double
  def round(x double) double

  def exp(x double) double
  def log(x double) double
  def pow(x double, y double) double
  def random double
  def sqrt(x double) double

  def max(x double, y double) double
  def max(x int, y int) int

  def min(x double, y double) double
  def min(x int, y int) int
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Unicode</button>
            <div class="reveal">
              <p>
                The string type stores unicode code units, not code points.
                See the documentation of "string" for more information.
              </p>
              <pre class="skew">namespace Unicode {
  enum Encoding {
    UTF8
    UTF16
    UTF32
  }

  # This is set to the string encoding for the current language target
  const STRING_ENCODING Encoding

  # This provides an efficient way to iterate over a string and access unicode
  # code points. Code points must be traversed using iteration because they
  # are encoded using a variable number of code units in UTF-8 and UTF-16.
  class StringIterator {
    var value string
    var index int
    var stop int

    def reset(text string, start int)
    def countCodePointsUntil(stop int) int
    def nextCodePoint int
  }

  namespace StringIterator {
    # This is provided for convenience and can be used to avoid GC churn
    const INSTANCE StringIterator
  }
}
</pre>
              <p>
                Example usage:
              </p>
              <pre class="skew">def countCodePointsInString(text string) int {
  var iterator = Unicode.StringIterator.INSTANCE
  iterator.reset(text, 0)
  return iterator.countCodePointsUntil(text.count)
}

def codePointAtIndex(text string, index int) int {
  var iterator = Unicode.StringIterator.INSTANCE
  iterator.reset(text, 0)
  iterator.countCodePointsUntil(index)
  return iterator.nextCodePoint
}</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Global constants</button>
            <div class="reveal">
              <pre class="skew">enum Target {
  NONE
  CPLUSPLUS
  CSHARP
  JAVASCRIPT
}

# This is set to the current language target
const TARGET Target

# This is true when the compiler is passed the <span class="chunk">"--release"</span> flag
const RELEASE bool</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Global functions</button>
            <div class="reveal">
              <pre class="skew"># This causes a runtime failure when passed "false". Calls to assert
# will be completely removed in release mode, so arguments won't
# be evaluated. This is accomplished with the "@skip" annotation.
def assert(truth bool)</pre>
            </div>
          </li>

          <li class="expandable">
            <button>Global annotations</button>
            <div class="reveal">
              <p>
                These annotations trigger special behaviors in the compiler for the symbols they annotate.
              </p>
              <pre class="skew"># Using "@alwaysinline" warns if inlining wasn't possible
def @alwaysinline
def @neverinline

# These cause warnings when the annotated symbol is used
def @deprecated
def @deprecated(message string)

# There can only be one active entry point during compilation. It must take
# no arguments or take a List&lt;string> and return either nothing or an int.
def @entry

# Imported code is assumed to exist and will not appear in the compiled result
def @import

# Exported code isn't dead stripped, minified, or otherwise altered
def @export

# This influences overload resolution for ambiguous matches
def @prefer

# Change the name of the annotated symbol during code generation
def @rename(name string)

# This causes calls to the function to be completely removed after type
# checking. This means the arguments will not be evaluated at the call site.
def @skip

# This is meant to be used for other annotations. When those annotations are
# on a function, "@spreads" causes those annotations to be propagated to
# other functions when that function is inlined inside them.
def @spreads

# This causes a C# "using" statement to be emitted when the symbol is used
def @using(name string)

# This causes a C++ "#include" pragma to be emitted when the symbol is used
def @include(name string)
</pre>
            </div>
          </li>
        </ul>
      </div>
    </section>

    <footer>
      <div class="inner">
        <a href="https://github.com/evanw/skew">GitHub Repository</a>
        <span>&bull;</span>
        <a href="https://github.com/evanw/skew/issues">Issue Tracker</a>
      </div>
    </footer>
  </body>
</html>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68409374-1', 'auto');
  ga('send', 'pageview');
</script>

<script src="ace.min.js"></script>
<script src="index.js"></script>
